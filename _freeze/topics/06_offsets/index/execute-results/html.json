{
  "hash": "b07c1cd8f31b7d8f915b4d2a12fea80b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Controlling for effort with `offset()`\"\neditor_options: \n  chunk_output_type: console\n---\n\n\nWe're going to search a plot and try to count all the individuals of a rare orchid. These orchids are rather rare, and even where they are common you're not likely to find them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(brms)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Rcpp\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading 'brms' package (version 2.23.0). Useful instructions\ncan be found by typing help('brms'). A more detailed introduction\nto the package is available through vignette('brms_overview').\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'brms'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:stats':\n\n    ar\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidybayes)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'tidybayes'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:brms':\n\n    dstudent_t, pstudent_t, qstudent_t, rstudent_t\n```\n\n\n:::\n\n```{.r .cell-code}\n# how many orchids in a hectare? that is 100 x 100 m, or 10 000 square meters\nplants_per_sq_m <- 4/1e4\ncount_per_ha <- rpois(1000, lambda = plants_per_sq_m*1e4)\nhist(count_per_ha)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmean(count_per_ha)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.943\n```\n\n\n:::\n\n```{.r .cell-code}\nvar(count_per_ha)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.945697\n```\n\n\n:::\n:::\n\n\nLet's say that surveys originally followed a protocol of searching rectangular transects for this plant. A single transect is 5m x 100m. Later, survey protocol was changed and the length of the transect was increased to 250m\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlabels <- c(\"small\", \"large\")\nsizes <- c(5*100, 5*250)\nflower_survey <- data_frame(group_id = rep(c(1, 2), each = 35),\n                            area_surveyed = sizes[group_id]) |> \n  mutate(flowers = rpois(length(group_id), lambda = area_surveyed*plants_per_sq_m))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `data_frame()` was deprecated in tibble 1.1.0.\nℹ Please use `tibble()` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(flower_survey, aes(x = flowers)) + geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`stat_bin()` using `bins = 30`. Pick better value `binwidth`.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nWe want to estimate the true density of the plant, which we know is 4\\times 10^{-4}. \n\nWhat happens if we ignore the area surveyed?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(coef(glm(flowers ~ 1, family = \"poisson\", data = flower_survey)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n  0.3428571 \n```\n\n\n:::\n:::\n\n\nnot surprisingly a VERY wrong answer! \n\nCan we \"standardize\" by count?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(with(flower_survey, flowers/area_surveyed))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.00036\n```\n\n\n:::\n\n```{.r .cell-code}\n# or:\n\nlm( I(flowers/area_surveyed) ~ 1, data = flower_survey)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = I(flowers/area_surveyed) ~ 1, data = flower_survey)\n\nCoefficients:\n(Intercept)  \n    0.00036  \n```\n\n\n:::\n:::\n\n\nThat gets us pretty close to the average count! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nflower_survey_stand <- mutate(flower_survey, per_m2 = flowers/area_surveyed)\n\nflowers_gauss_brm <- brm(formula = bf(per_m2 ~ 1, family = \"gaussian\"),\n    prior = c(\n      prior(normal(0.0005, 0.0001), class = \"Intercept\"),\n      prior(exponential(1), class = \"sigma\")\n    ),\n    data = flower_survey_stand,\n    refresh = 0L,\n    file = here::here(\"topics/06_offsets/flowers_gauss_brm\")\n    )\n```\n:::\n\n\nIt's really not far from the truth! But the model makes awkward predictions. \n\n\n::: {.cell}\n\n```{.r .cell-code}\npp_check(flowers_gauss_brm)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nUsing 10 posterior draws for ppc type 'dens_overlay' by default.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayesplot::mcmc_areas(flowers_gauss_brm, pars = \"Intercept\") + \n  geom_vline(xintercept = plants_per_sq_m, col = \"red\", size = 3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n## Using a Poisson offset\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflower_pois_bf <- bf(flowers ~ 1 + offset(log(area_surveyed)), family = \"poisson\")\n\nget_prior(flower_pois_bf, data = flower_survey)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIntercept ~ student_t(3, -8.97275346435927, 2.5)\n```\n\n\n:::\n:::\n\n\nNote that there is only one parameter, because the offset does not add  parameter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflower_pois_prior <- prior(normal(log(0.0005), .5), class = \"Intercept\")\n\nflower_pois_brm <- brm(flower_pois_bf, data = flower_survey, prior= flower_pois_prior, \n    refresh = 0L, file = here::here(\"topics/06_offsets/flower_pois_brm.rds\"))\n```\n:::\n\n\nPosterior predictive check shows a more satisfying prediction of the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npp_check(flower_pois_brm)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nUsing 10 posterior draws for ppc type 'dens_overlay' by default.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nWe get a similar posterior \n\n\n::: {.cell layout-nrow=\"2\"}\n\n```{.r .cell-code}\nget_variables(flower_pois_brm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"b_Intercept\"   \"Intercept\"     \"lprior\"        \"lp__\"         \n [5] \"accept_stat__\" \"stepsize__\"    \"treedepth__\"   \"n_leapfrog__\" \n [9] \"divergent__\"   \"energy__\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nbayesplot::mcmc_areas(flower_pois_brm, pars = \"Intercept\") + \n  geom_vline(xintercept = log(plants_per_sq_m), col = \"red\", size = 3)\n```\n\n::: {.cell-output-display}\n![Two ways to plot the posterior distribution of average flower number and compare it to the true values.](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\nflower_pois_brm |> \n  tidybayes::gather_draws(Intercept) |> \n  mutate(average = exp(.value)) |> \n  ggplot(aes(x = average)) + tidybayes::stat_halfeye() + \n  geom_vline(xintercept = plants_per_sq_m, col = \"red\", size = 3)\n```\n\n::: {.cell-output-display}\n![Two ways to plot the posterior distribution of average flower number and compare it to the true values.](index_files/figure-html/unnamed-chunk-11-2.png){width=672}\n:::\n:::\n\n\n## Why does it work\n\nThe `offset()` function simply adds a term to our linear predictor and gives it a coefficient of exactly 1 -- that is, it does not multiply it by anything at all. \nTogether with the link function, it lets us scale the mean of the model by a constant term. This helps us to control for exposure or effort, when you find more of the response because you search over a larger space:\n\n$$\n\\begin{align}\ny &\\sim \\text{Pois}(\\lambda) \\\\\ny &\\sim \\text{Pois}(e^\\alpha) \\\\\ny &\\sim \\text{Pois}(e^{\\beta_0 + \\text{offset}(\\ln(\\text{effort}))}) \\\\\ny &\\sim \\text{Pois}(e^{\\beta_0 + \\ln(\\text{effort})}) \\\\\ny &\\sim \\text{Pois}(e^{\\beta_0}e^{\\ln(\\text{effort})}) \\\\\ny &\\sim \\text{Pois}(\\text{effort}\\times e^{\\beta_0}) \\\\\n\\end{align}\n$$\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}